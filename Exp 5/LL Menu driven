// my code
#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *next;
};

struct node *head = NULL;

void createlist();
void displaylist();
void insertatbeginning();
void insertatend();
void insertatposition();
void deleteatbeginning();
void deleteatend();
void deleteatposition();
void countnodes();
void searchelem();
void reverselist();
     

int main(){
    int choice;
    while(1){
        printf("\nMENU :-");
        printf("\n1.Create");
        printf("\n2.Display");
        printf("\n3.Insert at beginning");
        printf("\n4.Insert at end");
        printf("\n5.Insert at position");
        printf("\n6.Delete at beginning");
        printf("\n7.Delete at end");
        printf("\n8.Delete at position");
        printf("\n9.Count no. of Nodes");
        printf("\n10.Search an element");
        printf("\n11.Reverse List");
        printf("\n12.Exit");
        printf("\nEnter your choice:");
        scanf("%d",&choice);
        
        switch(choice){
            case 1:createlist();break;
            case 2:displaylist();break;
            case 3:insertatbeginning();break;
            case 4:insertatend();break;
            case 5:insertatposition();break;
            case 6:deleteatbeginning();break;
            case 7:deleteatend();break;
            case 8:deleteatposition();break;
            case 9:countnodes();break;
            case 10:searchelem();break;
            case 11:reverselist();break;
            case 12:exit(0);
            default:printf("Invalid choice!");

        }
    }
return 0;
}
struct node *createnode(int element){
    struct node *temp;
    temp = (struct node*)malloc (sizeof(struct node));
    temp ->data = element;
    temp ->next = NULL;
    return temp;
    
}

void createlist(){
    int n ,element,i;
    printf("Enter size of list:");
    scanf("%d",&n);
    for(i=1;i<=n;i++){
    printf("Enter element no. %d : ",i);
    scanf("%d",&element);
    struct node *newnode = createnode(element);
    if (head==NULL) //empty
    head = newnode;
    else{
        struct node *temp = head;
        while(temp->next!=NULL) //iterate
        temp = temp->next;
        temp->next= newnode;
       }
    
    }
}
void displaylist(){
    if (head == NULL){
    printf("List is empty.");
    return;
    }
    
    struct node *temp = head; //initial value
    printf("List:");
    while(temp !=NULL){  //iterate
        printf("%d -> ",temp->data); //insert data
        temp = temp ->next; //icreament
    }
    printf("NULL\n"); //after last
    
    
}
void insertatbeginning(){
int element;
printf("Enter element:");
scanf("%d",&element);
struct node *newnode = createnode(element);
 newnode ->next = head; //link newnode to current first node
 head = newnode; //newnodes address in head
 }
 
 void insertatend(){
     int element;
     printf("Enter element:");
     scanf("%d",&element);
     struct node *newnode = createnode(element);
     if (head==NULL){ //list is empty
     head = newnode;
     return;
     }
     struct node *temp = head; //create pointer that moves
     while(temp->next != NULL) //iterate
         temp = temp->next; //increament
         temp->next = newnode;

     }
     
void insertatposition(){
    int element,pos;
     printf("Enter element:");
     scanf("%d",&element);
     printf("Enter position you want to enter at:");
     scanf("%d",&pos);
     struct node *newnode = createnode(element);
     if(pos==1){
         newnode ->next = head; //link newnode to current first node
         head = newnode; //newnodes address in head
         return;
     }
     struct node *temp = head;
     for(int i=1;temp!=NULL && i<pos-1;i++){  //index before position
         temp = temp->next;
     }
     if(temp==NULL) {    //end
         printf("Invalid position!");
         free(newnode);
         return;
     }
     newnode->next = temp->next;   //store address of next in newnode
     temp->next=newnode;           //store address of newnode in previous
}

void deleteatbeginning(){
    if(head==NULL){
        printf("List is empty");
        return;
    }
    struct node *temp = head;  
    head = head->next;  //assign to 2nd which will be 1st
    free(temp); //delete 1st
}

void deleteatend(){
if(head==NULL){
        printf("List is empty");
        return;
    } 
if(head->next==NULL){ //only one element
    free(head);
    head = NULL;
    return;
}
struct node *temp = head;
while(temp->next->next !=NULL) //second last
temp = temp->next;
free(temp->next);
temp->next = NULL;
}


void deleteatposition(){
    int pos;
    printf("Enter position to delete:");
    scanf("%d",&pos);
    if (head==NULL){
        printf("List is empty.");
        return;
    }
    if(pos==1){  //first node
        deleteatbeginning();
        return;
    }
    struct node *temp = head;
    for(int i=1;i<pos-1 && temp!=NULL;i++){   //reach at pos-1
        temp = temp->next;
    }
    if(temp==NULL || temp->next== NULL){     
        printf("Position out of range!");
        return;
    }
    struct node *del = temp->next;   
    temp->next = del->next;     // assign value to node before del node
    free(del);
    
    
}

void countnodes(){
    int count=0;
    struct node *temp = head;
    while(temp !=NULL){
        temp = temp->next;
        count++;
    }
    printf("Number of nodes in array is:%d",count);
    
    
}

void searchelem(){
    int key,pos=1;
    printf("Enter element you want to find:");
    scanf("%d",&key);
    struct node *temp = head;
    while(temp!=NULL){
        if(temp->data == key){
            printf("Element %d found at position %d",key,pos);
            return;
        }
            temp = temp->next;   //increament
            pos++;               // pos incr
    }
        
        printf("Element not found in the list.");
    
    
    
}

void reverselist(){
    struct node *prev=NULL,*curr=head,*next=NULL;  
    while(curr !=NULL){
        next = curr->next;    //make curr vacant
        curr->next = prev;     // store prev instead of next
        prev=curr;
        curr=next;               //move forward
    }
    head=prev;
    
    printf("List Reversed.");
    
}
    
     
     
    
